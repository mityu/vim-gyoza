" call themis#log(readfile(expand('<sfile>'))) | finish
let s:assert = themis#helper('assert')
call themis#helper('command').with(s:assert)
call themis#func_alias(s:assert)

let s:A = ScriptFuncs('autoload/gyoza/applier.vim')
let s:C = ScriptFuncs('autoload/gyoza/config.vim')

Describe Applier class
  Before all
    command ResetOptions
      \ set expandtab& smarttab& shiftwidth& tabstop& backspace&
    call test_override('char_avail', 1)
    let NewConfig = s:C.new_rule_stack
    filetype indent on
    call gyoza#applier#set_callback_on_finish_applicant({-> 0})
  End

  After all
    %bwipeout!
    ResetOptions
    call test_override('char_avail', 0)
    unlet NewConfig
    delcommand ResetOptions
    filetype indent off
    call gyoza#applier#set_callback_on_finish_applicant(v:null)
  End

  Before each
    %bwipeout!
    ResetOptions
    set filetype=vim
  End

  It is a validation.
    " Check for the auto indentation.
    Feedkeys iif foo<CR>aaa<CR>endif<ESC>
    Assert Equals(GetAllLines(), ['if foo', "\taaa", 'endif'])
  End

  It completes closing pair with no indentation.
    let rules = NewConfig().add_rule('^\s*if\>', 'endif')._rules
    call NewScripter()
      \.feedkeys('iif aaa<CR>')
      \.call({-> gyoza#applier#trigger_applicant(rules)})
      \.feedkeys('')
      \.call({-> s:assert.equals(GetAllLines(), ['if aaa', "\t", 'endif'])})
      \.call({-> s:assert.equals(GetCurpos(), [2, 2])})
      \.run()
  End

  It completes closing pair with indentation.
    let rules = NewConfig().add_rule('^\s*if\>', 'endif')._rules
    call NewScripter()
      \.feedkeys('i<Tab>if aaa<CR>')
      \.call({-> gyoza#applier#trigger_applicant(rules)})
      \.feedkeys('')
      \.call({-> s:assert.equals(GetAllLines(), ["\tif aaa", "\t\t", "\tendif"])})
      \.call({-> s:assert.equals(GetCurpos(), [2, 3])})
      \.run()
  End

  It completes closing pair with some rules.
    let rules = NewConfig()
      \.add_rule('^\s*if\>', 'endif')
      \.add_rule('^\s*while\>', 'endwhile')
      \._rules
    call NewScripter()
      \.feedkeys('iwhile<CR>')
      \.call({-> gyoza#applier#trigger_applicant(rules)})
      \.feedkeys('')
      \.call({-> s:assert.equals(GetAllLines(), ['while', "\t", 'endwhile'])})
      \.call({-> s:assert.equals(GetCurpos(), [2, 2])})
      \.run()
  End

  It applies the first matched rule.
    let rules = NewConfig()
      \.add_rule('^\s*if\>', 'endif')
      \.add_rule('^\s*if\>', 'end')
      \._rules
    call NewScripter()
      \.feedkeys('iif<CR>')
      \.call({-> gyoza#applier#trigger_applicant(rules)})
      \.feedkeys('')
      \.call({-> s:assert.equals(GetAllLines(), ['if', "\t", 'endif'])})
      \.call({-> s:assert.equals(GetCurpos(), [2, 2])})
      \.run()
  End

  It does not complete pair if next line has deeper indentation.
    let rules = NewConfig().add_rule('^\s*if\>', 'endif')._rules
    call setline(1, ['if aaa', "\tfoo"])
    call NewScripter()
      \.feedkeys('ggo')
      \.call({-> gyoza#applier#trigger_applicant(rules)})
      \.feedkeys('')
      \.call({-> s:assert.equals(GetAllLines(), ['if aaa', "\t", "\tfoo"])})
      \.call({-> s:assert.equals(GetCurpos(), [2, 2])})
      \.run()
  End

  It does not complete pair if there's already the pair.
    let rules = NewConfig().add_rule('^\s*if\>', 'endif')._rules
    call setline(1, ['if', 'endif'])
    call NewScripter()
      \.feedkeys('ggo')
      \.call({-> gyoza#applier#trigger_applicant(rules)})
      \.feedkeys('')
      \.call({-> s:assert.equals(GetAllLines(), ['if', "\t", 'endif'])})
      \.call({-> s:assert.equals(GetCurpos(), [2, 2])})
      \.run()
  End

  It doesn't complete pair when second newline.
    let rules = NewConfig().add_rule('^\s*if\>', 'endif')._rules
    call NewScripter()
      \.feedkeys('iif<CR>')
      \.call({-> gyoza#applier#trigger_applicant(rules)})
      \.feedkeys('<CR>')
      \.call({-> gyoza#applier#trigger_applicant(rules)})
      \.feedkeys('')
      \.call({-> s:assert.equals(GetAllLines(), ['if', '', "\t", 'endif'])})
      \.call({-> s:assert.equals(GetCurpos(), [3, 2])})
      \.run()
  End

  It removes current line if leaving insert mode just after newline.
    let rules = NewConfig().add_rule('^\s*if\>', 'endif')._rules
    call NewScripter()
      \.feedkeys('iif<CR>')
      \.call({-> gyoza#applier#trigger_applicant(rules)})
      \.feedkeys('<ESC>')
      \.call({-> s:assert.equals(GetAllLines(), ['if', 'endif'])})
      \.call({-> s:assert.equals(GetCurpos(), [2, 1])})
      \.run()
  End

  It removes current line if leaving insert mode just after newline (with indentation).
    set expandtab smarttab shiftwidth=2
    let rules = NewConfig().add_rule('^\s*if\>', 'endif')._rules
    call NewScripter()
      \.feedkeys('i<Tab>if<CR>')
      \.call({-> gyoza#applier#trigger_applicant(rules)})
      \.feedkeys('<ESC>')
      \.call({-> s:assert.equals(GetAllLines(), ['  if', '  endif'])})
      \.call({-> s:assert.equals(GetCurpos(), [2, 3])})
      \.run()
  End

  It doesn't remove current line when leaving insert mode after typing some words.
    let rules = NewConfig().add_rule('^\s*if\>', 'endif')._rules
    call NewScripter()
      \.feedkeys('iif<CR>')
      \.call({-> gyoza#applier#trigger_applicant(rules)})
      \.feedkeys('foo<ESC>')
      \.call({-> s:assert.equals(GetAllLines(), ['if', "\tfoo", 'endif'])})
      \.call({-> s:assert.equals(GetCurpos(), [2, 4])})
      \.run()
  End

  It doesn't remove current line when leaving insert mode after typing <C-h>.
    set backspace=indent
    let rules = NewConfig().add_rule('^\s*if\>', 'endif')._rules
    call NewScripter()
      \.feedkeys('iif<CR>')
      \.call({-> gyoza#applier#trigger_applicant(rules)})
      \.call({-> s:assert.equals(GetCurpos(), [2, 2])})
      \.feedkeys('<C-u>')
      \.call({-> s:assert.equals(GetAllLines(), ['if', '', 'endif'])})
      \.feedkeys('<ESC>')
      \.call({-> s:assert.equals(GetAllLines(), ['if', '', 'endif'])})
      \.call({-> s:assert.equals(GetCurpos(), [2, 1])})
      \.run()
  End

  It doesn't remove current line when type <CR> twice.
    let rules = NewConfig().add_rule('^\s*if\>', 'endif')._rules
    call NewScripter()
      \.feedkeys('iif<CR>')
      \.call({-> gyoza#applier#trigger_applicant(rules)})
      \.feedkeys('<CR>')
      \.call({-> gyoza#applier#trigger_applicant(rules)})
      \.feedkeys('<ESC>')
      \.call({-> s:assert.equals(GetAllLines(), ['if', '', '', 'endif'])})
      \.call({-> s:assert.equals(GetCurpos(), [3, 1])})
      \.run()
  End

  It can undo step by step.
    set expandtab smarttab shiftwidth=2

    let undo0 =<< trim END
    if
      aaaa
    endif
    END

    let undo1 =<< trim END
    if
    endif
    END

    let rules = NewConfig().add_rule('^\s*if\>', 'endif')._rules
    call NewScripter()
      \.feedkeys('iif<CR>')
      \.call({-> gyoza#applier#trigger_applicant(rules)})
      \.feedkeys('aaaa<ESC>')
      \.run()
    Assert Equals(GetAllLines(), undo0)
    Assert Equals(GetCurpos(), [2, 6])
    normal! u
    Assert Equals(GetAllLines(), undo1)
    Assert Equals(GetCurpos(), [2, 5])
    normal! u
    Assert Equals(GetAllLines(), [''])
    Assert Equals(GetCurpos(), [1, 1])
  End

  It doesn't create a undo block for newline removal.
    set expandtab smarttab shiftwidth=2

    let undo0 =<< trim END
    if
    endif
    END

    let rules = NewConfig().add_rule('^\s*if\>', 'endif')._rules
    call NewScripter()
      \.feedkeys('iif<CR>')
      \.call({-> gyoza#applier#trigger_applicant(rules)})
      \.feedkeys('<ESC>')
      \.run()
    Assert Equals(GetAllLines(), undo0)
    Assert Equals(GetCurpos(), [2, 1])
    normal! u
    Assert Equals(GetAllLines(), [''])
    Assert Equals(GetCurpos(), [1, 1])
  End

  It doesn't create a new undo block after newline if user created it.
    set expandtab smarttab shiftwidth=2

    let undo0 =<< trim END
    if
      a
    endif
    END

    let undo1 =<< trim END
    if

    endif
    END
    let undo1[1] = '  '

    let undo2 = ['']

    let rules = NewConfig().add_rule('^\s*if\>', 'endif')._rules

    call NewScripter()
      \.feedkeys('iif<CR>')
      \.call({-> gyoza#applier#trigger_applicant(rules)})
      \.call({-> s:assert.equals(GetAllLines(), undo1)})
      \.feedkeys('<C-g>ua')
      \.call({-> s:assert.equals(GetAllLines(), undo0)})
      \.feedkeys('<ESC>')
      \.run()
    Assert Equals(GetAllLines(), undo0)
    Assert Equals(GetCurpos(), [2, 3])
    normal! u
    Assert Equals(GetAllLines(), undo1)
    Assert Equals(GetCurpos(), [2, 2])
    normal! u
    Assert Equals(GetAllLines(), undo2)
    Assert Equals(GetCurpos(), [1, 1])
  End

  It keeps text after cursor.
    TODO not implemented yet.
    " TODO: Is this behavior truely appriciated? Maybe this is needless?
    let rules = NewConfig().add_rule('^\s*if\>', 'endif')._rules
    call setline(1, 'iffoo')
    call NewScripter()
      \.feedkeys('^la<CR>')
      \.call({-> s:assert.equals(GetAllLines(), ['if', "\tfoo", 'endif'])})
      \.run()
  End

  It doesn't complete pair if it's already at the tail of cursor.
    TODO not implemented yet.
    let rules = NewConfig().add_rule('^\s*if\>', 'endif')._rules

    call setline(1, 'ifendif')
    call NewScripter()
      \.feedkeys('^la<CR>')
      \.call({-> gyoza#applier#trigger_applicant(rules)})
      \.call({-> s:assert.equals(GetAllLines(), ['if', "\t", 'endif'])})
      \.run()
  End

  It doesn't complete pair if there's some "another pair"s like "else" for "if".
    TODO not implemented yet
    let lines =<< trim END
    if
    else
    endif
    END

    let rules = NewConfig().add_rule('^\s*if\>', 'endif', ['else'])._rules

    call setline(1, lines)
    call NewScripter()
      \.feedkeys('ggo')
      \.call({-> gyoza#applier#trigger_applicant(rules)})
      \.call({-> s:assert.equals(GetAllLines(), ['if', "\t", 'else', 'endif'])})
      \.call({-> s:assert.equals(GetCurpos(), [2, 2])})
      \.feedkeys('<CR>')
      \.call({-> s:assert.equals(GetAllLines(), lines)})
      \.call({-> s:assert.equals(GetCurpos(), [2, 1])})
      \.run()
  End

  It clears temporal mappings properly.
    let rules = NewConfig().add_rule('^\s*if\>', 'endif')._rules
    call NewScripter()
      \.feedkeys('iif<CR>')
      \.call({-> gyoza#applier#trigger_applicant(rules)})
      \.feedkeys('<ESC>')
      \.run()
    let maps = execute('imap <Plug>')->trim()->split("\n")
    Assert Equals(maps, ['No mapping found'])
  End

End
