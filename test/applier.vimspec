" call themis#log(readfile(expand('<sfile>'))) | finish
let s:assert = themis#helper('assert')
call themis#helper('command').with(s:assert)
call themis#func_alias(s:assert)

let s:A = ScriptFuncs('autoload/gyoza/applier.vim')
let s:C = ScriptFuncs('autoload/gyoza/config.vim')

Describe Applier class
  Before all
    command ResetOptions
      \ set expandtab& smarttab& shiftwidth& tabstop& backspace&
    call test_override('char_avail', 1)
    let NewConfig = s:C.new_rule_stack
    filetype indent on
    call gyoza#applier#set_callback_on_finish_applicant({-> 0})
  End

  After all
    %bwipeout!
    ResetOptions
    call test_override('char_avail', 0)
    unlet NewConfig
    delcommand ResetOptions
    filetype indent off
    call gyoza#applier#set_callback_on_finish_applicant(v:null)
  End

  Before each
    %bwipeout!
    ResetOptions
    set filetype=vim
  End

  It is a validation.
    " Check for the auto indentation.
    Feedkeys iif foo<CR>aaa<CR>endif<ESC>
    Assert Equals(GetAllLines(), ['if foo', "\taaa", 'endif'])
  End

  It completes closing pair with no indentation.
    let rules = NewConfig().add_rule('^\s*if\>', 'endif')._rules
    call NewScripter()
      \.feedkeys('iif aaa<CR>')
      \.call({-> gyoza#applier#trigger_applicant(rules)})
      \.feedkeys('')
      \.call({-> s:assert.equals(GetAllLines(), ['if aaa', "\t", 'endif'])})
      \.call({-> s:assert.equals(GetCurpos(), [2, 2])})
      \.run()
  End

  It completes closing pair with indentation.
    let rules = NewConfig().add_rule('^\s*if\>', 'endif')._rules
    call NewScripter()
      \.feedkeys('i<Tab>if aaa<CR>')
      \.call({-> gyoza#applier#trigger_applicant(rules)})
      \.feedkeys('')
      \.call({-> s:assert.equals(GetAllLines(), ["\tif aaa", "\t\t", "\tendif"])})
      \.call({-> s:assert.equals(GetCurpos(), [2, 3])})
      \.run()
  End

  It completes closing pair with some rules.
    let rules = NewConfig()
      \.add_rule('^\s*if\>', 'endif')
      \.add_rule('^\s*while\>', 'endwhile')
      \._rules
    call NewScripter()
      \.feedkeys('iwhile<CR>')
      \.call({-> gyoza#applier#trigger_applicant(rules)})
      \.feedkeys('')
      \.call({-> s:assert.equals(GetAllLines(), ['while', "\t", 'endwhile'])})
      \.call({-> s:assert.equals(GetCurpos(), [2, 2])})
      \.run()
  End

  It applies the first matched rule.
    let rules = NewConfig()
      \.add_rule('^\s*if\>', 'endif')
      \.add_rule('^\s*if\>', 'end')
      \._rules
    call NewScripter()
      \.feedkeys('iif<CR>')
      \.call({-> gyoza#applier#trigger_applicant(rules)})
      \.feedkeys('')
      \.call({-> s:assert.equals(GetAllLines(), ['if', "\t", 'endif'])})
      \.call({-> s:assert.equals(GetCurpos(), [2, 2])})
      \.run()
  End

  It does not complete pair if next line has deeper indentation.
    let rules = NewConfig().add_rule('^\s*if\>', 'endif')._rules
    call setline(1, ['if aaa', "\tfoo"])
    call NewScripter()
      \.feedkeys('ggo')
      \.call({-> gyoza#applier#trigger_applicant(rules)})
      \.feedkeys('')
      \.call({-> s:assert.equals(GetAllLines(), ['if aaa', "\t", "\tfoo"])})
      \.call({-> s:assert.equals(GetCurpos(), [2, 2])})
      \.run()
  End

  It does not complete pair if there's already the pair.
    let rules = NewConfig().add_rule('^\s*if\>', 'endif')._rules
    call setline(1, ['if', 'endif'])
    call NewScripter()
      \.feedkeys('ggo')
      \.call({-> gyoza#applier#trigger_applicant(rules)})
      \.feedkeys('')
      \.call({-> s:assert.equals(GetAllLines(), ['if', "\t", 'endif'])})
      \.call({-> s:assert.equals(GetCurpos(), [2, 2])})
      \.run()
  End

  It handles indentation properly when using hardtabs in space-indented buffer.
    set tabstop=2 shiftwidth=2 expandtab
    let rules = NewConfig().add_rule('^\s*if\>', 'endif')._rules
    call setline(1, ["\tif"])
    call NewScripter()
      \.feedkeys('o')
      \.call({-> gyoza#applier#trigger_applicant(rules)})
      \.feedkeys('')
      \.call({-> s:assert.equals(GetAllLines(), ["\tif", '    ', '  endif'])})
      \.call({-> s:assert.equals(GetCurpos(), [2, 5])})
      \.run()
  End

  It handles indentation properly when using softtabs in hardtab-indented buffer.
    set tabstop=2 shiftwidth=2
    let rules = NewConfig().add_rule('^\s*if\>', 'endif')._rules
    call setline(1, ['  if'])
    call NewScripter()
      \.feedkeys('o')
      \.call({-> gyoza#applier#trigger_applicant(rules)})
      \.feedkeys('')
      \.call({-> s:assert.equals(GetAllLines())})
  End

  It handles indentation properly when using softtabs in hardtab-indented buffer.
    set tabstop=4 shiftwidth=2
  End

  It cancel pair completion properly when using hardtabs in space-indented buffer.
    set tabstop=2 shiftwidth=2
    let rules = NewConfig().add_rule('^\s*if\>', 'endif')._rules
    call setline(1, ['  if', '  endif'])
    call NewScripter()
      \.feedkeys('ggo')
      \.call({-> gyoza#applier#trigger_applicant(rules)})
      \.feedkeys('')
      \.call({-> s:assert.equals(GetAllLines(), ['  if', "\t\t", '  endif'])})
      \.call({-> s:assert.equals(GetCurpos(), [2, 3])})
      \.run()
  End

  It handles pair completion properly when using softtabs in hardtab-indented buffer.
    set tabstop=2 shiftwidth=2 expandtab
    let rules = NewConfig().add_rule('^\s*if\>', 'endif')._rules
    let lines = map(['if', 'endif'], '"\t" . v:val')
    call setline(1, lines)
    call NewScripter()
      \.feedkeys('ggo')
      \.call({-> gyoza#applier#trigger_applicant(rules)})
      \.feedkeys('')
      \.call({-> s:assert.equals(GetAllLines(), insert(copy(lines), '    ', 1))})
      \.call({-> s:assert.equals(GetCurpos(), [2, 5])})
      \.run()
  End

  It doesn't complete pair when second newline.
    let rules = NewConfig().add_rule('^\s*if\>', 'endif')._rules
    call NewScripter()
      \.feedkeys('iif<CR>')
      \.call({-> gyoza#applier#trigger_applicant(rules)})
      \.feedkeys('<CR>')
      \.call({-> gyoza#applier#trigger_applicant(rules)})
      \.feedkeys('')
      \.call({-> s:assert.equals(GetAllLines(), ['if', '', "\t", 'endif'])})
      \.call({-> s:assert.equals(GetCurpos(), [3, 2])})
      \.run()
  End

  It removes current line if leaving insert mode just after newline.
    let rules = NewConfig().add_rule('^\s*if\>', 'endif')._rules
    call NewScripter()
      \.feedkeys('iif<CR>')
      \.call({-> gyoza#applier#trigger_applicant(rules)})
      \.feedkeys('<ESC>')
      \.call({-> s:assert.equals(GetAllLines(), ['if', 'endif'])})
      \.call({-> s:assert.equals(GetCurpos(), [2, 1])})
      \.run()
  End

  It removes current line if leaving insert mode just after newline (with indentation).
    set expandtab smarttab shiftwidth=2
    let rules = NewConfig().add_rule('^\s*if\>', 'endif')._rules
    call NewScripter()
      \.feedkeys('i<Tab>if<CR>')
      \.call({-> gyoza#applier#trigger_applicant(rules)})
      \.feedkeys('<ESC>')
      \.call({-> s:assert.equals(GetAllLines(), ['  if', '  endif'])})
      \.call({-> s:assert.equals(GetCurpos(), [2, 3])})
      \.run()
  End

  It doesn't remove current line when leaving insert mode after typing some words.
    let rules = NewConfig().add_rule('^\s*if\>', 'endif')._rules
    call NewScripter()
      \.feedkeys('iif<CR>')
      \.call({-> gyoza#applier#trigger_applicant(rules)})
      \.feedkeys('foo<ESC>')
      \.call({-> s:assert.equals(GetAllLines(), ['if', "\tfoo", 'endif'])})
      \.call({-> s:assert.equals(GetCurpos(), [2, 4])})
      \.run()
  End

  It doesn't remove current line when leaving insert mode after typing <C-h>.
    set backspace=indent
    let rules = NewConfig().add_rule('^\s*if\>', 'endif')._rules
    call NewScripter()
      \.feedkeys('iif<CR>')
      \.call({-> gyoza#applier#trigger_applicant(rules)})
      \.call({-> s:assert.equals(GetCurpos(), [2, 2])})
      \.feedkeys('<C-u>')
      \.call({-> s:assert.equals(GetAllLines(), ['if', '', 'endif'])})
      \.feedkeys('<ESC>')
      \.call({-> s:assert.equals(GetAllLines(), ['if', '', 'endif'])})
      \.call({-> s:assert.equals(GetCurpos(), [2, 1])})
      \.run()
  End

  It doesn't remove current line when type <CR> twice.
    let rules = NewConfig().add_rule('^\s*if\>', 'endif')._rules
    call NewScripter()
      \.feedkeys('iif<CR>')
      \.call({-> gyoza#applier#trigger_applicant(rules)})
      \.feedkeys('<CR>')
      \.call({-> gyoza#applier#trigger_applicant(rules)})
      \.feedkeys('<ESC>')
      \.call({-> s:assert.equals(GetAllLines(), ['if', '', '', 'endif'])})
      \.call({-> s:assert.equals(GetCurpos(), [3, 1])})
      \.run()
  End

  It doesn't apply rule when canceler is on the next line (literal).
    let lines =<< trim END
    if
    else
    endif
    END

    let rules = NewConfig().add_rule('^\s*if\>', 'endif', ['else'])._rules

    call setline(1, lines)
    call NewScripter()
      \.feedkeys('ggo')
      \.call({-> gyoza#applier#trigger_applicant(rules)})
      \.call({-> s:assert.equals(GetAllLines(), insert(copy(lines), "\t", 1))})
      \.call({-> s:assert.equals(GetCurpos(), [2, 2])})
      \.feedkeys('<CR>')
      \.call({-> s:assert.equals(GetAllLines(), flatten(insert(copy(lines), ['', "\t"], 1)))})
      \.call({-> s:assert.equals(GetCurpos(), [3, 2])})
      \.feedkeys('<ESC>')
      \.run()
  End

  It doesn't apply rule when canceler is on the next line (regexp).
    let lines =<< trim END
    if
    elseif condition
    endif
    END
    call map(lines, '"\t" . v:val')  " Add an indentation.

    let rules = NewConfig().add_rule('^\s*if\>', 'endif', ['\=^elseif\>\s'])._rules

    call setline(1, lines)
    call NewScripter()
      \.feedkeys('ggo')
      \.call({-> gyoza#applier#trigger_applicant(rules)})
      \.call({-> s:assert.equals(GetAllLines(), insert(copy(lines), "\t\t", 1))})
      \.call({-> s:assert.equals(GetCurpos(), [2, 3])})
      \.feedkeys('<ESC>')
      \.run()
  End

  It doesn't consider as valid canceler if indentation depth is different (literal).
    let lines =<< trim END
    if foo
      else
    END

    let rules = NewConfig().add_rule('^\s*if\>', 'endif', ['else'])._rules

    set expandtab smarttab shiftwidth=2
    call setline(1, lines)
    call NewScripter()
      \.feedkeys('ggo')
      \.call({-> gyoza#applier#trigger_applicant(rules)})
      \.call({-> s:assert.equals(GetAllLines(), insert(copy(lines), "  ", 1))})
      \.call({-> s:assert.equals(GetCurpos(), [2, 3])})
      \.run()
  End

  It doesn't consider as valid canceler if indentation depth is different (regexp).
    let lines =<< trim END
    if cond1
      elseif cond2
    END

    let rules = NewConfig().add_rule('^\s*if\>', 'endif', ['\=^elseif\>\s'])._rules

    set expandtab smarttab shiftwidth=2
    call setline(1, lines)
    call NewScripter()
      \.feedkeys('ggo')
      \.call({-> gyoza#applier#trigger_applicant(rules)})
      \.call({-> s:assert.equals(GetAllLines(), insert(copy(lines), "  ", 1))})
      \.call({-> s:assert.equals(GetCurpos(), [2, 3])})
      \.run()
  End

  It can undo step by step.
    set expandtab smarttab shiftwidth=2

    let undo0 =<< trim END
    if
      aaaa
    endif
    END

    let undo1 =<< trim END
    if
    endif
    END

    let rules = NewConfig().add_rule('^\s*if\>', 'endif')._rules
    call NewScripter()
      \.feedkeys('iif<CR>')
      \.call({-> gyoza#applier#trigger_applicant(rules)})
      \.feedkeys('aaaa<ESC>')
      \.run()
    Assert Equals(GetAllLines(), undo0)
    Assert Equals(GetCurpos(), [2, 6])
    normal! u
    Assert Equals(GetAllLines(), undo1)
    Assert Equals(GetCurpos(), [2, 5])
    normal! u
    Assert Equals(GetAllLines(), [''])
    Assert Equals(GetCurpos(), [1, 1])
  End

  It doesn't create a undo block for newline removal.
    set expandtab smarttab shiftwidth=2

    let undo0 =<< trim END
    if
    endif
    END

    let rules = NewConfig().add_rule('^\s*if\>', 'endif')._rules
    call NewScripter()
      \.feedkeys('iif<CR>')
      \.call({-> gyoza#applier#trigger_applicant(rules)})
      \.feedkeys('<ESC>')
      \.run()
    Assert Equals(GetAllLines(), undo0)
    Assert Equals(GetCurpos(), [2, 1])
    normal! u
    Assert Equals(GetAllLines(), [''])
    Assert Equals(GetCurpos(), [1, 1])
  End

  It doesn't create a new undo block after newline if user created it.
    set expandtab smarttab shiftwidth=2

    let undo0 =<< trim END
    if
      a
    endif
    END

    let undo1 =<< trim END
    if

    endif
    END
    let undo1[1] = '  '

    let undo2 = ['']

    let rules = NewConfig().add_rule('^\s*if\>', 'endif')._rules

    call NewScripter()
      \.feedkeys('iif<CR>')
      \.call({-> gyoza#applier#trigger_applicant(rules)})
      \.call({-> s:assert.equals(GetAllLines(), undo1)})
      \.feedkeys('<C-g>ua')
      \.call({-> s:assert.equals(GetAllLines(), undo0)})
      \.feedkeys('<ESC>')
      \.run()
    Assert Equals(GetAllLines(), undo0)
    Assert Equals(GetCurpos(), [2, 3])
    normal! u
    Assert Equals(GetAllLines(), undo1)
    Assert Equals(GetCurpos(), [2, 2])
    normal! u
    Assert Equals(GetAllLines(), undo2)
    Assert Equals(GetCurpos(), [1, 1])
  End

  It keeps text after cursor when the first rule is applied.
    let rules = NewConfig().add_rule('^\s*if\>', 'endif')._rules
    call setline(1, 'iffoo')
    call NewScripter()
      \.feedkeys('^la<CR>')
      \.call({-> gyoza#applier#trigger_applicant(rules)})
      \.call({-> s:assert.equals(GetAllLines(), ['if', "\tfoo", 'endif'])})
      \.call({-> s:assert.equals(GetCurpos(), [2, 2])})
      \.run()
  End

  It keeps text after cursor when the second rule is applied.
    let rules = NewConfig()
      \.add_rule('^\s*while\>', 'endwhile')
      \.add_rule('^\s*if\>', 'endif')
      \._rules
    call setline(1, 'iffoo')
    call NewScripter()
      \.feedkeys('^la<CR>')
      \.call({-> gyoza#applier#trigger_applicant(rules)})
      \.call({-> s:assert.equals(GetAllLines(), ['if', "\tfoo", 'endif'])})
      \.call({-> s:assert.equals(GetCurpos(), [2, 2])})
      \.run()
  End

  It clears temporal mappings properly.
    let rules = NewConfig().add_rule('^\s*if\>', 'endif')._rules
    call NewScripter()
      \.feedkeys('iif<CR>')
      \.call({-> gyoza#applier#trigger_applicant(rules)})
      \.feedkeys('<ESC>')
      \.run()
    let maps = execute('imap <Plug>')->trim()->split("\n")
    Assert Equals(maps, ['No mapping found'])
  End

End
